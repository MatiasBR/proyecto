Terminals unused in grammar

    DO
    EXTERN
    ERROR


State 5 conflicts: 2 shift/reduce


Grammar

    0 $accept: program $end

    1 program: PROGRAM LBRACE var_decl_list method_decl_list RBRACE

    2 var_decl_list: %empty
    3              | var_decl_list var_decl

    4 method_decl_list: %empty
    5                 | method_decl_list method_decl

    6 var_decl: type IDENTIFIER SEMICOLON

    7 method_decl: type_or_void IDENTIFIER LPAREN param_list RPAREN block

    8 type_or_void: type
    9             | VOID

   10 param_list: %empty
   11           | type IDENTIFIER
   12           | param_list COMMA type IDENTIFIER

   13 block: LBRACE statement_list RBRACE

   14 statement_list: %empty
   15               | statement_list statement

   16 type: INTEGER
   17     | BOOL

   18 statement: var_decl
   19          | IDENTIFIER ASSIGN expr SEMICOLON
   20          | method_call SEMICOLON
   21          | IF expr THEN block else_part
   22          | WHILE expr block
   23          | RETURN expr_opt SEMICOLON
   24          | block

   25 else_part: %empty
   26          | ELSE block

   27 expr_opt: %empty
   28         | expr

   29 method_call: IDENTIFIER LPAREN arg_list RPAREN

   30 arg_list: %empty
   31         | expr
   32         | arg_list COMMA expr

   33 expr: literal
   34     | IDENTIFIER
   35     | method_call
   36     | expr PLUS expr
   37     | expr MINUS expr
   38     | expr MULTIPLY expr
   39     | expr DIVIDE expr
   40     | expr MODULO expr
   41     | expr LESS expr
   42     | expr GREATER expr
   43     | expr EQUAL expr
   44     | expr AND expr
   45     | expr OR expr
   46     | MINUS expr
   47     | NOT expr
   48     | LPAREN expr RPAREN

   49 literal: INTEGER_LITERAL
   50        | TRUE
   51        | FALSE


Terminals, with rules where they appear

    $end (0) 0
    error (256)
    INTEGER_LITERAL <int_val> (258) 49
    IDENTIFIER <string_val> (259) 6 7 11 12 19 29 34
    PROGRAM (260) 1
    BOOL (261) 17
    DO (262)
    ELSE (263) 26
    EXTERN (264)
    FALSE (265) 51
    IF (266) 21
    INTEGER (267) 16
    RETURN (268) 23
    THEN (269) 21
    TRUE (270) 50
    VOID (271) 9
    WHILE (272) 22
    PLUS (273) 36
    MINUS (274) 37 46
    MULTIPLY (275) 38
    DIVIDE (276) 39
    MODULO (277) 40
    LESS (278) 41
    GREATER (279) 42
    EQUAL (280) 43
    AND (281) 44
    OR (282) 45
    NOT (283) 47
    ASSIGN (284) 19
    LPAREN (285) 7 29 48
    RPAREN (286) 7 29 48
    LBRACE (287) 1 13
    RBRACE (288) 1 13
    SEMICOLON (289) 6 19 20 23
    COMMA (290) 12 32
    ERROR (291)
    UMINUS (292)


Nonterminals, with rules where they appear

    $accept (38)
        on left: 0
    program <node> (39)
        on left: 1
        on right: 0
    var_decl_list <node> (40)
        on left: 2 3
        on right: 1 3
    method_decl_list <node> (41)
        on left: 4 5
        on right: 1 5
    var_decl <node> (42)
        on left: 6
        on right: 3 18
    method_decl <node> (43)
        on left: 7
        on right: 5
    type_or_void <node> (44)
        on left: 8 9
        on right: 7
    param_list <node> (45)
        on left: 10 11 12
        on right: 7 12
    block <node> (46)
        on left: 13
        on right: 7 21 22 24 26
    statement_list <node> (47)
        on left: 14 15
        on right: 13 15
    type <node> (48)
        on left: 16 17
        on right: 6 8 11 12
    statement <node> (49)
        on left: 18 19 20 21 22 23 24
        on right: 15
    else_part <node> (50)
        on left: 25 26
        on right: 21
    expr_opt <node> (51)
        on left: 27 28
        on right: 23
    method_call <node> (52)
        on left: 29
        on right: 20 35
    arg_list <node> (53)
        on left: 30 31 32
        on right: 29 32
    expr <node> (54)
        on left: 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48
        on right: 19 21 22 28 31 32 36 37 38 39 40 41 42 43 44 45 46 47 48
    literal <node> (55)
        on left: 49 50 51
        on right: 33


State 0

    0 $accept: . program $end

    PROGRAM  shift, and go to state 1

    program  go to state 2


State 1

    1 program: PROGRAM . LBRACE var_decl_list method_decl_list RBRACE

    LBRACE  shift, and go to state 3


State 2

    0 $accept: program . $end

    $end  shift, and go to state 4


State 3

    1 program: PROGRAM LBRACE . var_decl_list method_decl_list RBRACE

    $default  reduce using rule 2 (var_decl_list)

    var_decl_list  go to state 5


State 4

    0 $accept: program $end .

    $default  accept


State 5

    1 program: PROGRAM LBRACE var_decl_list . method_decl_list RBRACE
    3 var_decl_list: var_decl_list . var_decl

    BOOL     shift, and go to state 6
    INTEGER  shift, and go to state 7

    BOOL      [reduce using rule 4 (method_decl_list)]
    INTEGER   [reduce using rule 4 (method_decl_list)]
    $default  reduce using rule 4 (method_decl_list)

    method_decl_list  go to state 8
    var_decl          go to state 9
    type              go to state 10


State 6

   17 type: BOOL .

    $default  reduce using rule 17 (type)


State 7

   16 type: INTEGER .

    $default  reduce using rule 16 (type)


State 8

    1 program: PROGRAM LBRACE var_decl_list method_decl_list . RBRACE
    5 method_decl_list: method_decl_list . method_decl

    BOOL     shift, and go to state 6
    INTEGER  shift, and go to state 7
    VOID     shift, and go to state 11
    RBRACE   shift, and go to state 12

    method_decl   go to state 13
    type_or_void  go to state 14
    type          go to state 15


State 9

    3 var_decl_list: var_decl_list var_decl .

    $default  reduce using rule 3 (var_decl_list)


State 10

    6 var_decl: type . IDENTIFIER SEMICOLON

    IDENTIFIER  shift, and go to state 16


State 11

    9 type_or_void: VOID .

    $default  reduce using rule 9 (type_or_void)


State 12

    1 program: PROGRAM LBRACE var_decl_list method_decl_list RBRACE .

    $default  reduce using rule 1 (program)


State 13

    5 method_decl_list: method_decl_list method_decl .

    $default  reduce using rule 5 (method_decl_list)


State 14

    7 method_decl: type_or_void . IDENTIFIER LPAREN param_list RPAREN block

    IDENTIFIER  shift, and go to state 17


State 15

    8 type_or_void: type .

    $default  reduce using rule 8 (type_or_void)


State 16

    6 var_decl: type IDENTIFIER . SEMICOLON

    SEMICOLON  shift, and go to state 18


State 17

    7 method_decl: type_or_void IDENTIFIER . LPAREN param_list RPAREN block

    LPAREN  shift, and go to state 19


State 18

    6 var_decl: type IDENTIFIER SEMICOLON .

    $default  reduce using rule 6 (var_decl)


State 19

    7 method_decl: type_or_void IDENTIFIER LPAREN . param_list RPAREN block

    BOOL     shift, and go to state 6
    INTEGER  shift, and go to state 7

    $default  reduce using rule 10 (param_list)

    param_list  go to state 20
    type        go to state 21


State 20

    7 method_decl: type_or_void IDENTIFIER LPAREN param_list . RPAREN block
   12 param_list: param_list . COMMA type IDENTIFIER

    RPAREN  shift, and go to state 22
    COMMA   shift, and go to state 23


State 21

   11 param_list: type . IDENTIFIER

    IDENTIFIER  shift, and go to state 24


State 22

    7 method_decl: type_or_void IDENTIFIER LPAREN param_list RPAREN . block

    LBRACE  shift, and go to state 25

    block  go to state 26


State 23

   12 param_list: param_list COMMA . type IDENTIFIER

    BOOL     shift, and go to state 6
    INTEGER  shift, and go to state 7

    type  go to state 27


State 24

   11 param_list: type IDENTIFIER .

    $default  reduce using rule 11 (param_list)


State 25

   13 block: LBRACE . statement_list RBRACE

    $default  reduce using rule 14 (statement_list)

    statement_list  go to state 28


State 26

    7 method_decl: type_or_void IDENTIFIER LPAREN param_list RPAREN block .

    $default  reduce using rule 7 (method_decl)


State 27

   12 param_list: param_list COMMA type . IDENTIFIER

    IDENTIFIER  shift, and go to state 29


State 28

   13 block: LBRACE statement_list . RBRACE
   15 statement_list: statement_list . statement

    IDENTIFIER  shift, and go to state 30
    BOOL        shift, and go to state 6
    IF          shift, and go to state 31
    INTEGER     shift, and go to state 7
    RETURN      shift, and go to state 32
    WHILE       shift, and go to state 33
    LBRACE      shift, and go to state 25
    RBRACE      shift, and go to state 34

    var_decl     go to state 35
    block        go to state 36
    type         go to state 10
    statement    go to state 37
    method_call  go to state 38


State 29

   12 param_list: param_list COMMA type IDENTIFIER .

    $default  reduce using rule 12 (param_list)


State 30

   19 statement: IDENTIFIER . ASSIGN expr SEMICOLON
   29 method_call: IDENTIFIER . LPAREN arg_list RPAREN

    ASSIGN  shift, and go to state 39
    LPAREN  shift, and go to state 40


State 31

   21 statement: IF . expr THEN block else_part

    INTEGER_LITERAL  shift, and go to state 41
    IDENTIFIER       shift, and go to state 42
    FALSE            shift, and go to state 43
    TRUE             shift, and go to state 44
    MINUS            shift, and go to state 45
    NOT              shift, and go to state 46
    LPAREN           shift, and go to state 47

    method_call  go to state 48
    expr         go to state 49
    literal      go to state 50


State 32

   23 statement: RETURN . expr_opt SEMICOLON

    INTEGER_LITERAL  shift, and go to state 41
    IDENTIFIER       shift, and go to state 42
    FALSE            shift, and go to state 43
    TRUE             shift, and go to state 44
    MINUS            shift, and go to state 45
    NOT              shift, and go to state 46
    LPAREN           shift, and go to state 47

    $default  reduce using rule 27 (expr_opt)

    expr_opt     go to state 51
    method_call  go to state 48
    expr         go to state 52
    literal      go to state 50


State 33

   22 statement: WHILE . expr block

    INTEGER_LITERAL  shift, and go to state 41
    IDENTIFIER       shift, and go to state 42
    FALSE            shift, and go to state 43
    TRUE             shift, and go to state 44
    MINUS            shift, and go to state 45
    NOT              shift, and go to state 46
    LPAREN           shift, and go to state 47

    method_call  go to state 48
    expr         go to state 53
    literal      go to state 50


State 34

   13 block: LBRACE statement_list RBRACE .

    $default  reduce using rule 13 (block)


State 35

   18 statement: var_decl .

    $default  reduce using rule 18 (statement)


State 36

   24 statement: block .

    $default  reduce using rule 24 (statement)


State 37

   15 statement_list: statement_list statement .

    $default  reduce using rule 15 (statement_list)


State 38

   20 statement: method_call . SEMICOLON

    SEMICOLON  shift, and go to state 54


State 39

   19 statement: IDENTIFIER ASSIGN . expr SEMICOLON

    INTEGER_LITERAL  shift, and go to state 41
    IDENTIFIER       shift, and go to state 42
    FALSE            shift, and go to state 43
    TRUE             shift, and go to state 44
    MINUS            shift, and go to state 45
    NOT              shift, and go to state 46
    LPAREN           shift, and go to state 47

    method_call  go to state 48
    expr         go to state 55
    literal      go to state 50


State 40

   29 method_call: IDENTIFIER LPAREN . arg_list RPAREN

    INTEGER_LITERAL  shift, and go to state 41
    IDENTIFIER       shift, and go to state 42
    FALSE            shift, and go to state 43
    TRUE             shift, and go to state 44
    MINUS            shift, and go to state 45
    NOT              shift, and go to state 46
    LPAREN           shift, and go to state 47

    $default  reduce using rule 30 (arg_list)

    method_call  go to state 48
    arg_list     go to state 56
    expr         go to state 57
    literal      go to state 50


State 41

   49 literal: INTEGER_LITERAL .

    $default  reduce using rule 49 (literal)


State 42

   29 method_call: IDENTIFIER . LPAREN arg_list RPAREN
   34 expr: IDENTIFIER .

    LPAREN  shift, and go to state 40

    $default  reduce using rule 34 (expr)


State 43

   51 literal: FALSE .

    $default  reduce using rule 51 (literal)


State 44

   50 literal: TRUE .

    $default  reduce using rule 50 (literal)


State 45

   46 expr: MINUS . expr

    INTEGER_LITERAL  shift, and go to state 41
    IDENTIFIER       shift, and go to state 42
    FALSE            shift, and go to state 43
    TRUE             shift, and go to state 44
    MINUS            shift, and go to state 45
    NOT              shift, and go to state 46
    LPAREN           shift, and go to state 47

    method_call  go to state 48
    expr         go to state 58
    literal      go to state 50


State 46

   47 expr: NOT . expr

    INTEGER_LITERAL  shift, and go to state 41
    IDENTIFIER       shift, and go to state 42
    FALSE            shift, and go to state 43
    TRUE             shift, and go to state 44
    MINUS            shift, and go to state 45
    NOT              shift, and go to state 46
    LPAREN           shift, and go to state 47

    method_call  go to state 48
    expr         go to state 59
    literal      go to state 50


State 47

   48 expr: LPAREN . expr RPAREN

    INTEGER_LITERAL  shift, and go to state 41
    IDENTIFIER       shift, and go to state 42
    FALSE            shift, and go to state 43
    TRUE             shift, and go to state 44
    MINUS            shift, and go to state 45
    NOT              shift, and go to state 46
    LPAREN           shift, and go to state 47

    method_call  go to state 48
    expr         go to state 60
    literal      go to state 50


State 48

   35 expr: method_call .

    $default  reduce using rule 35 (expr)


State 49

   21 statement: IF expr . THEN block else_part
   36 expr: expr . PLUS expr
   37     | expr . MINUS expr
   38     | expr . MULTIPLY expr
   39     | expr . DIVIDE expr
   40     | expr . MODULO expr
   41     | expr . LESS expr
   42     | expr . GREATER expr
   43     | expr . EQUAL expr
   44     | expr . AND expr
   45     | expr . OR expr

    THEN      shift, and go to state 61
    PLUS      shift, and go to state 62
    MINUS     shift, and go to state 63
    MULTIPLY  shift, and go to state 64
    DIVIDE    shift, and go to state 65
    MODULO    shift, and go to state 66
    LESS      shift, and go to state 67
    GREATER   shift, and go to state 68
    EQUAL     shift, and go to state 69
    AND       shift, and go to state 70
    OR        shift, and go to state 71


State 50

   33 expr: literal .

    $default  reduce using rule 33 (expr)


State 51

   23 statement: RETURN expr_opt . SEMICOLON

    SEMICOLON  shift, and go to state 72


State 52

   28 expr_opt: expr .
   36 expr: expr . PLUS expr
   37     | expr . MINUS expr
   38     | expr . MULTIPLY expr
   39     | expr . DIVIDE expr
   40     | expr . MODULO expr
   41     | expr . LESS expr
   42     | expr . GREATER expr
   43     | expr . EQUAL expr
   44     | expr . AND expr
   45     | expr . OR expr

    PLUS      shift, and go to state 62
    MINUS     shift, and go to state 63
    MULTIPLY  shift, and go to state 64
    DIVIDE    shift, and go to state 65
    MODULO    shift, and go to state 66
    LESS      shift, and go to state 67
    GREATER   shift, and go to state 68
    EQUAL     shift, and go to state 69
    AND       shift, and go to state 70
    OR        shift, and go to state 71

    $default  reduce using rule 28 (expr_opt)


State 53

   22 statement: WHILE expr . block
   36 expr: expr . PLUS expr
   37     | expr . MINUS expr
   38     | expr . MULTIPLY expr
   39     | expr . DIVIDE expr
   40     | expr . MODULO expr
   41     | expr . LESS expr
   42     | expr . GREATER expr
   43     | expr . EQUAL expr
   44     | expr . AND expr
   45     | expr . OR expr

    PLUS      shift, and go to state 62
    MINUS     shift, and go to state 63
    MULTIPLY  shift, and go to state 64
    DIVIDE    shift, and go to state 65
    MODULO    shift, and go to state 66
    LESS      shift, and go to state 67
    GREATER   shift, and go to state 68
    EQUAL     shift, and go to state 69
    AND       shift, and go to state 70
    OR        shift, and go to state 71
    LBRACE    shift, and go to state 25

    block  go to state 73


State 54

   20 statement: method_call SEMICOLON .

    $default  reduce using rule 20 (statement)


State 55

   19 statement: IDENTIFIER ASSIGN expr . SEMICOLON
   36 expr: expr . PLUS expr
   37     | expr . MINUS expr
   38     | expr . MULTIPLY expr
   39     | expr . DIVIDE expr
   40     | expr . MODULO expr
   41     | expr . LESS expr
   42     | expr . GREATER expr
   43     | expr . EQUAL expr
   44     | expr . AND expr
   45     | expr . OR expr

    PLUS       shift, and go to state 62
    MINUS      shift, and go to state 63
    MULTIPLY   shift, and go to state 64
    DIVIDE     shift, and go to state 65
    MODULO     shift, and go to state 66
    LESS       shift, and go to state 67
    GREATER    shift, and go to state 68
    EQUAL      shift, and go to state 69
    AND        shift, and go to state 70
    OR         shift, and go to state 71
    SEMICOLON  shift, and go to state 74


State 56

   29 method_call: IDENTIFIER LPAREN arg_list . RPAREN
   32 arg_list: arg_list . COMMA expr

    RPAREN  shift, and go to state 75
    COMMA   shift, and go to state 76


State 57

   31 arg_list: expr .
   36 expr: expr . PLUS expr
   37     | expr . MINUS expr
   38     | expr . MULTIPLY expr
   39     | expr . DIVIDE expr
   40     | expr . MODULO expr
   41     | expr . LESS expr
   42     | expr . GREATER expr
   43     | expr . EQUAL expr
   44     | expr . AND expr
   45     | expr . OR expr

    PLUS      shift, and go to state 62
    MINUS     shift, and go to state 63
    MULTIPLY  shift, and go to state 64
    DIVIDE    shift, and go to state 65
    MODULO    shift, and go to state 66
    LESS      shift, and go to state 67
    GREATER   shift, and go to state 68
    EQUAL     shift, and go to state 69
    AND       shift, and go to state 70
    OR        shift, and go to state 71

    $default  reduce using rule 31 (arg_list)


State 58

   36 expr: expr . PLUS expr
   37     | expr . MINUS expr
   38     | expr . MULTIPLY expr
   39     | expr . DIVIDE expr
   40     | expr . MODULO expr
   41     | expr . LESS expr
   42     | expr . GREATER expr
   43     | expr . EQUAL expr
   44     | expr . AND expr
   45     | expr . OR expr
   46     | MINUS expr .

    $default  reduce using rule 46 (expr)


State 59

   36 expr: expr . PLUS expr
   37     | expr . MINUS expr
   38     | expr . MULTIPLY expr
   39     | expr . DIVIDE expr
   40     | expr . MODULO expr
   41     | expr . LESS expr
   42     | expr . GREATER expr
   43     | expr . EQUAL expr
   44     | expr . AND expr
   45     | expr . OR expr
   47     | NOT expr .

    $default  reduce using rule 47 (expr)


State 60

   36 expr: expr . PLUS expr
   37     | expr . MINUS expr
   38     | expr . MULTIPLY expr
   39     | expr . DIVIDE expr
   40     | expr . MODULO expr
   41     | expr . LESS expr
   42     | expr . GREATER expr
   43     | expr . EQUAL expr
   44     | expr . AND expr
   45     | expr . OR expr
   48     | LPAREN expr . RPAREN

    PLUS      shift, and go to state 62
    MINUS     shift, and go to state 63
    MULTIPLY  shift, and go to state 64
    DIVIDE    shift, and go to state 65
    MODULO    shift, and go to state 66
    LESS      shift, and go to state 67
    GREATER   shift, and go to state 68
    EQUAL     shift, and go to state 69
    AND       shift, and go to state 70
    OR        shift, and go to state 71
    RPAREN    shift, and go to state 77


State 61

   21 statement: IF expr THEN . block else_part

    LBRACE  shift, and go to state 25

    block  go to state 78


State 62

   36 expr: expr PLUS . expr

    INTEGER_LITERAL  shift, and go to state 41
    IDENTIFIER       shift, and go to state 42
    FALSE            shift, and go to state 43
    TRUE             shift, and go to state 44
    MINUS            shift, and go to state 45
    NOT              shift, and go to state 46
    LPAREN           shift, and go to state 47

    method_call  go to state 48
    expr         go to state 79
    literal      go to state 50


State 63

   37 expr: expr MINUS . expr

    INTEGER_LITERAL  shift, and go to state 41
    IDENTIFIER       shift, and go to state 42
    FALSE            shift, and go to state 43
    TRUE             shift, and go to state 44
    MINUS            shift, and go to state 45
    NOT              shift, and go to state 46
    LPAREN           shift, and go to state 47

    method_call  go to state 48
    expr         go to state 80
    literal      go to state 50


State 64

   38 expr: expr MULTIPLY . expr

    INTEGER_LITERAL  shift, and go to state 41
    IDENTIFIER       shift, and go to state 42
    FALSE            shift, and go to state 43
    TRUE             shift, and go to state 44
    MINUS            shift, and go to state 45
    NOT              shift, and go to state 46
    LPAREN           shift, and go to state 47

    method_call  go to state 48
    expr         go to state 81
    literal      go to state 50


State 65

   39 expr: expr DIVIDE . expr

    INTEGER_LITERAL  shift, and go to state 41
    IDENTIFIER       shift, and go to state 42
    FALSE            shift, and go to state 43
    TRUE             shift, and go to state 44
    MINUS            shift, and go to state 45
    NOT              shift, and go to state 46
    LPAREN           shift, and go to state 47

    method_call  go to state 48
    expr         go to state 82
    literal      go to state 50


State 66

   40 expr: expr MODULO . expr

    INTEGER_LITERAL  shift, and go to state 41
    IDENTIFIER       shift, and go to state 42
    FALSE            shift, and go to state 43
    TRUE             shift, and go to state 44
    MINUS            shift, and go to state 45
    NOT              shift, and go to state 46
    LPAREN           shift, and go to state 47

    method_call  go to state 48
    expr         go to state 83
    literal      go to state 50


State 67

   41 expr: expr LESS . expr

    INTEGER_LITERAL  shift, and go to state 41
    IDENTIFIER       shift, and go to state 42
    FALSE            shift, and go to state 43
    TRUE             shift, and go to state 44
    MINUS            shift, and go to state 45
    NOT              shift, and go to state 46
    LPAREN           shift, and go to state 47

    method_call  go to state 48
    expr         go to state 84
    literal      go to state 50


State 68

   42 expr: expr GREATER . expr

    INTEGER_LITERAL  shift, and go to state 41
    IDENTIFIER       shift, and go to state 42
    FALSE            shift, and go to state 43
    TRUE             shift, and go to state 44
    MINUS            shift, and go to state 45
    NOT              shift, and go to state 46
    LPAREN           shift, and go to state 47

    method_call  go to state 48
    expr         go to state 85
    literal      go to state 50


State 69

   43 expr: expr EQUAL . expr

    INTEGER_LITERAL  shift, and go to state 41
    IDENTIFIER       shift, and go to state 42
    FALSE            shift, and go to state 43
    TRUE             shift, and go to state 44
    MINUS            shift, and go to state 45
    NOT              shift, and go to state 46
    LPAREN           shift, and go to state 47

    method_call  go to state 48
    expr         go to state 86
    literal      go to state 50


State 70

   44 expr: expr AND . expr

    INTEGER_LITERAL  shift, and go to state 41
    IDENTIFIER       shift, and go to state 42
    FALSE            shift, and go to state 43
    TRUE             shift, and go to state 44
    MINUS            shift, and go to state 45
    NOT              shift, and go to state 46
    LPAREN           shift, and go to state 47

    method_call  go to state 48
    expr         go to state 87
    literal      go to state 50


State 71

   45 expr: expr OR . expr

    INTEGER_LITERAL  shift, and go to state 41
    IDENTIFIER       shift, and go to state 42
    FALSE            shift, and go to state 43
    TRUE             shift, and go to state 44
    MINUS            shift, and go to state 45
    NOT              shift, and go to state 46
    LPAREN           shift, and go to state 47

    method_call  go to state 48
    expr         go to state 88
    literal      go to state 50


State 72

   23 statement: RETURN expr_opt SEMICOLON .

    $default  reduce using rule 23 (statement)


State 73

   22 statement: WHILE expr block .

    $default  reduce using rule 22 (statement)


State 74

   19 statement: IDENTIFIER ASSIGN expr SEMICOLON .

    $default  reduce using rule 19 (statement)


State 75

   29 method_call: IDENTIFIER LPAREN arg_list RPAREN .

    $default  reduce using rule 29 (method_call)


State 76

   32 arg_list: arg_list COMMA . expr

    INTEGER_LITERAL  shift, and go to state 41
    IDENTIFIER       shift, and go to state 42
    FALSE            shift, and go to state 43
    TRUE             shift, and go to state 44
    MINUS            shift, and go to state 45
    NOT              shift, and go to state 46
    LPAREN           shift, and go to state 47

    method_call  go to state 48
    expr         go to state 89
    literal      go to state 50


State 77

   48 expr: LPAREN expr RPAREN .

    $default  reduce using rule 48 (expr)


State 78

   21 statement: IF expr THEN block . else_part

    ELSE  shift, and go to state 90

    $default  reduce using rule 25 (else_part)

    else_part  go to state 91


State 79

   36 expr: expr . PLUS expr
   36     | expr PLUS expr .
   37     | expr . MINUS expr
   38     | expr . MULTIPLY expr
   39     | expr . DIVIDE expr
   40     | expr . MODULO expr
   41     | expr . LESS expr
   42     | expr . GREATER expr
   43     | expr . EQUAL expr
   44     | expr . AND expr
   45     | expr . OR expr

    MULTIPLY  shift, and go to state 64
    DIVIDE    shift, and go to state 65
    MODULO    shift, and go to state 66

    $default  reduce using rule 36 (expr)


State 80

   36 expr: expr . PLUS expr
   37     | expr . MINUS expr
   37     | expr MINUS expr .
   38     | expr . MULTIPLY expr
   39     | expr . DIVIDE expr
   40     | expr . MODULO expr
   41     | expr . LESS expr
   42     | expr . GREATER expr
   43     | expr . EQUAL expr
   44     | expr . AND expr
   45     | expr . OR expr

    MULTIPLY  shift, and go to state 64
    DIVIDE    shift, and go to state 65
    MODULO    shift, and go to state 66

    $default  reduce using rule 37 (expr)


State 81

   36 expr: expr . PLUS expr
   37     | expr . MINUS expr
   38     | expr . MULTIPLY expr
   38     | expr MULTIPLY expr .
   39     | expr . DIVIDE expr
   40     | expr . MODULO expr
   41     | expr . LESS expr
   42     | expr . GREATER expr
   43     | expr . EQUAL expr
   44     | expr . AND expr
   45     | expr . OR expr

    $default  reduce using rule 38 (expr)


State 82

   36 expr: expr . PLUS expr
   37     | expr . MINUS expr
   38     | expr . MULTIPLY expr
   39     | expr . DIVIDE expr
   39     | expr DIVIDE expr .
   40     | expr . MODULO expr
   41     | expr . LESS expr
   42     | expr . GREATER expr
   43     | expr . EQUAL expr
   44     | expr . AND expr
   45     | expr . OR expr

    $default  reduce using rule 39 (expr)


State 83

   36 expr: expr . PLUS expr
   37     | expr . MINUS expr
   38     | expr . MULTIPLY expr
   39     | expr . DIVIDE expr
   40     | expr . MODULO expr
   40     | expr MODULO expr .
   41     | expr . LESS expr
   42     | expr . GREATER expr
   43     | expr . EQUAL expr
   44     | expr . AND expr
   45     | expr . OR expr

    $default  reduce using rule 40 (expr)


State 84

   36 expr: expr . PLUS expr
   37     | expr . MINUS expr
   38     | expr . MULTIPLY expr
   39     | expr . DIVIDE expr
   40     | expr . MODULO expr
   41     | expr . LESS expr
   41     | expr LESS expr .
   42     | expr . GREATER expr
   43     | expr . EQUAL expr
   44     | expr . AND expr
   45     | expr . OR expr

    PLUS      shift, and go to state 62
    MINUS     shift, and go to state 63
    MULTIPLY  shift, and go to state 64
    DIVIDE    shift, and go to state 65
    MODULO    shift, and go to state 66

    $default  reduce using rule 41 (expr)


State 85

   36 expr: expr . PLUS expr
   37     | expr . MINUS expr
   38     | expr . MULTIPLY expr
   39     | expr . DIVIDE expr
   40     | expr . MODULO expr
   41     | expr . LESS expr
   42     | expr . GREATER expr
   42     | expr GREATER expr .
   43     | expr . EQUAL expr
   44     | expr . AND expr
   45     | expr . OR expr

    PLUS      shift, and go to state 62
    MINUS     shift, and go to state 63
    MULTIPLY  shift, and go to state 64
    DIVIDE    shift, and go to state 65
    MODULO    shift, and go to state 66

    $default  reduce using rule 42 (expr)


State 86

   36 expr: expr . PLUS expr
   37     | expr . MINUS expr
   38     | expr . MULTIPLY expr
   39     | expr . DIVIDE expr
   40     | expr . MODULO expr
   41     | expr . LESS expr
   42     | expr . GREATER expr
   43     | expr . EQUAL expr
   43     | expr EQUAL expr .
   44     | expr . AND expr
   45     | expr . OR expr

    PLUS      shift, and go to state 62
    MINUS     shift, and go to state 63
    MULTIPLY  shift, and go to state 64
    DIVIDE    shift, and go to state 65
    MODULO    shift, and go to state 66
    LESS      shift, and go to state 67
    GREATER   shift, and go to state 68

    $default  reduce using rule 43 (expr)


State 87

   36 expr: expr . PLUS expr
   37     | expr . MINUS expr
   38     | expr . MULTIPLY expr
   39     | expr . DIVIDE expr
   40     | expr . MODULO expr
   41     | expr . LESS expr
   42     | expr . GREATER expr
   43     | expr . EQUAL expr
   44     | expr . AND expr
   44     | expr AND expr .
   45     | expr . OR expr

    PLUS      shift, and go to state 62
    MINUS     shift, and go to state 63
    MULTIPLY  shift, and go to state 64
    DIVIDE    shift, and go to state 65
    MODULO    shift, and go to state 66
    LESS      shift, and go to state 67
    GREATER   shift, and go to state 68
    EQUAL     shift, and go to state 69

    $default  reduce using rule 44 (expr)


State 88

   36 expr: expr . PLUS expr
   37     | expr . MINUS expr
   38     | expr . MULTIPLY expr
   39     | expr . DIVIDE expr
   40     | expr . MODULO expr
   41     | expr . LESS expr
   42     | expr . GREATER expr
   43     | expr . EQUAL expr
   44     | expr . AND expr
   45     | expr . OR expr
   45     | expr OR expr .

    PLUS      shift, and go to state 62
    MINUS     shift, and go to state 63
    MULTIPLY  shift, and go to state 64
    DIVIDE    shift, and go to state 65
    MODULO    shift, and go to state 66
    LESS      shift, and go to state 67
    GREATER   shift, and go to state 68
    EQUAL     shift, and go to state 69
    AND       shift, and go to state 70

    $default  reduce using rule 45 (expr)


State 89

   32 arg_list: arg_list COMMA expr .
   36 expr: expr . PLUS expr
   37     | expr . MINUS expr
   38     | expr . MULTIPLY expr
   39     | expr . DIVIDE expr
   40     | expr . MODULO expr
   41     | expr . LESS expr
   42     | expr . GREATER expr
   43     | expr . EQUAL expr
   44     | expr . AND expr
   45     | expr . OR expr

    PLUS      shift, and go to state 62
    MINUS     shift, and go to state 63
    MULTIPLY  shift, and go to state 64
    DIVIDE    shift, and go to state 65
    MODULO    shift, and go to state 66
    LESS      shift, and go to state 67
    GREATER   shift, and go to state 68
    EQUAL     shift, and go to state 69
    AND       shift, and go to state 70
    OR        shift, and go to state 71

    $default  reduce using rule 32 (arg_list)


State 90

   26 else_part: ELSE . block

    LBRACE  shift, and go to state 25

    block  go to state 92


State 91

   21 statement: IF expr THEN block else_part .

    $default  reduce using rule 21 (statement)


State 92

   26 else_part: ELSE block .

    $default  reduce using rule 26 (else_part)
